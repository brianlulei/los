#include <include/memlayout.h>
#include <kernel/pmap.h>
#include <kernel/kclock.h>
#include <include/stdio.h>
#include <include/assert.h>
#include <include/string.h>

// These variables are set by i386_detect_memory()
size_t			npages;			// Amount of physical memory (in pages)
static size_t	npages_basemem;	// Amount of base memory (in pages)


// These variables are set in mem_init()
pde_t *kern_pgdir;					// Kernel's initial page directory
PageInfo *pages;					// physical page state array
static PageInfo *page_free_list;	// Free list of physical pages

/*******************************************
 * Detect machine's physical memory setup. *
 *******************************************/
static int
nvram_read(int r)
{
	// Read both low and high bytes to compute the whole value
	return mc146818_read(r) | (mc146818_read(r + 1) << 8);
}


static void
i386_detect_memory(void)
{
	size_t npages_extmem;

	// Use CMOS calls to measure available base & extended memory.
	npages_basemem = (nvram_read(NVRAM_BASELO) * 1024) / PGSIZE;
	npages_extmem = (nvram_read(NVRAM_EXTLO) * 1024) / PGSIZE;

	if (npages_extmem)
		npages = (EXTPHYSMEM / PGSIZE) + npages_extmem;
	else
		npages = npages_basemem;


	cprintf("Physical memory: %uK available, base = %uK, extended = %uK\n",
			npages * PGSIZE / 1024, 
			npages_basemem * PGSIZE / 1024,
			npages_extmem * PGSIZE / 1024);

}


// -------------------------------------
// Set up memory mappings
// -------------------------------------

static void		check_page_free_list(bool only_low_memory);
static void		check_page_alloc(void);


/* This is a simple physical memory allocator used only while LOS
 * is setting up its virtual memory system.
 *
 * If n > 0, allocates enough pages of contiguous physical memory to hold
 * 'n' bytes. Doesn't initialize the memory. Returns a kernel virtual address.
 *
 * If n == 0, returns the address of the next free page without allocating anything.
 *
 * If out of memory, boot_alloc should panic.
 */

static void*
boot_alloc(uint32_t n)
{
	static char *nextfree = NULL;	// virtual address of next byte of free memory
	char *result;

	// Initialize nextfree if this the first time.
	// 'end' is a symbol automatically generated by the linker,
	// which points to the end of the kernel's bss segment:
	// the first virtual address that the linker does *not* assign
	// to any kernel code or global variables.
	if (!nextfree) {
		extern char end[];
		nextfree = ROUNDUP((char *) end, PGSIZE);
	}

	// Allocate a chunk large enough to hold 'n' bytes, then update
	// nextfree. Make sure nextfree is kept alined to a multiple of PGSIZE

	result = nextfree;
	nextfree = ROUNDUP((nextfree + n), PGSIZE);

	if (PGNUM(PADDR(nextfree)) > npages)
		panic("NO ENOUGH MEMORY");

	return result;
}

/* Set up a two level page table:
 *
 */
void
mem_init(void)
{
	// Find out how much memory the machine has (npages & npages_basemem).
	i386_detect_memory();

	/********************************
	 * Create initial page directory
	 ********************************/
	kern_pgdir = (pde_t *) boot_alloc(PGSIZE);
	memset(kern_pgdir, 0, PGSIZE);

	/***********************************************************
	 * Recursively insert PD in itself as a page table, to form
	 * a virtual page table at virtual address UVPT.
	 ***********************************************************/
	//kern_pgdir

	/*************************************************************************
     * Allocate an array of npages 'struct PageInfo's and store it in 'pages'.
	 * The kernel uses this array to keep track of physical pages: for each
	 * physical page, there is a corresponding struct PageInfo in this array.
	 * 'npages' is the number of physical pages in memory. Use memset to
	 * initialize all fields of each struct PageInfo to 0.
	 *************************************************************************/
	uint32_t pginfo_size = npages * sizeof(PageInfo);
	pages = (PageInfo *) boot_alloc(pginfo_size);
	memset(pages, 0, pginfo_size);

	/*************************************************************************
	 * Now that we've allocated the initial kernel data structures, we set up
	 * the list of free physical pages. Once we've done so, all further memory
	 * management will go through the page_* functions. In particular, we can
	 * now map memory using boot_map_region or page_insert
	 *************************************************************************/

	page_init();

	check_page_free_list(1);
	check_page_alloc();
	panic("mem_init: This function is not finished\n");
}
 


/*********************************************************************
 * Initialize page structure and memory free list.
 * After this is done, NEVER use boot_alloc again. ONLY use the page
 * allocator functions below to allocate and deallocate physical
 * memory via the page_free_list.
 *********************************************************************/
void
page_init(void)
{
	// The example code here marks all physical pages as free.
    // However this is not truly the case.  What memory is free?
    //  1) Mark physical page 0 as in use.
    //     This way we preserve the real-mode IDT and BIOS structures
    //     in case we ever need them.  (Currently we don't, but...)
    //  2) The rest of base memory, [PGSIZE, npages_basemem * PGSIZE)
    //     is free.
    //  3) Then comes the IO hole [IOPHYSMEM, EXTPHYSMEM), which must
    //     never be allocated.
    //  4) Then extended memory [EXTPHYSMEM, ...).
    //     Some of it is in use, some is free. Where is the kernel
    //     in physical memory?  Which pages are already in use for
    //     page tables and other data structures?
    //  
    // Change the code to reflect this.
    size_t i;
	extern char end[];

	// 1. Mark physical page 0 as in use.
	pages[0].pp_ref = 0;
	pages[0].pp_link = NULL;
	
	// 2. Mark [PGSIZE, npages_basemem * PGSIZE) free.
	// i is starting from 1
    for (i = 1; i < npages_basemem; i++) {
        pages[i].pp_ref = 0;
        pages[i].pp_link = page_free_list;
        page_free_list = &pages[i];
    }

	// 3. Mark [IOPHYSMEM, EXTPHYSMEM) in use.
	uint32_t ext_page_num = PGNUM(ROUNDUP(EXTPHYSMEM, PGSIZE));
	assert(npages > ext_page_num);

    for (i = npages_basemem; i < ext_page_num; i++) {
        pages[i].pp_ref = 0;
        pages[i].pp_link = NULL;
    }

	// 4. Mark [EXTPHYSMEM, end) in use.
	uint32_t kernel_end_page_num = PGNUM(ROUNDUP(PADDR(end), PGSIZE));

	for (i = ext_page_num; i < kernel_end_page_num; i++) {
		pages[i].pp_ref = 0;
		pages[i].pp_link = NULL;
	}
	
	// 5. Mark kern_pgdir in use.
	uint32_t pginfo_size = npages * sizeof(PageInfo);
	uint32_t pginfo_page_num = PGNUM(ROUNDUP(pginfo_size, PGSIZE));

	// additional 1 is for initial page directory
	for (i = ext_page_num; i < kernel_end_page_num + pginfo_page_num + 1; i++) {
		pages[i].pp_ref = 0;
		pages[i].pp_link = NULL;
	}

	// 6. Mark rest pages free.
	for (; i < npages; i++) {
        pages[i].pp_ref = 0;
        pages[i].pp_link = page_free_list;
        page_free_list = &pages[i];	
	}
}


/******************************************************************************
 * Allocates a physical page. If (alloc_flags & ALLOC_ZERO), fills the entire
 * returned physical page with '\0' bytes. Does NOT increment the reference
 * count of the page - the caller must do these if necessary (either explicitly
 * or via page_insert).
 *
 * Be sure to set the pp_link field of the allocated page to NULL so
 * page_free can check for double-free bugs.
 * 
 * Returns NULL if out of free memory.
 ******************************************************************************/
PageInfo *
page_alloc(int alloc_flags)
{
	PageInfo * page = NULL;
	
	if (page_free_list) {	// if it has free page
		page = page_free_list;
		page_free_list = page_free_list->pp_link;
		page->pp_link = NULL;

		if (alloc_flags && ALLOC_ZERO)
			memset(page2kva(page), 0, PGSIZE);
	}

	return page;
}

/******************************************************************
 * Return a page to the free list.
 * This function should only be called when pp->pp_ref reaches 0.
 ******************************************************************/
void
page_free(PageInfo *pp)
{
	// You may want to panic if pp->pp_ref is nonzero or pp->pp_link is not NULL
	if (pp == NULL)
		return;

	assert(!pp->pp_ref && !pp->pp_link);

	pp->pp_link = page_free_list;
	page_free_list = pp;
}

// -----------------------------------------------------
// Checking functions
// -----------------------------------------------------

static void
check_page_free_list(bool only_low_memory)
{
    PageInfo *pp;
    unsigned pdx_limit = only_low_memory ? 1 : NPDENTRIES;
    int nfree_basemem = 0, nfree_extmem = 0;
    char *first_free_page;

    if (!page_free_list)
        panic("'page_free_list' is a null pointer!");

    if (only_low_memory) {
        // Move pages with lower addresses first in the free
        // list, since entry_pgdir does not map all pages.
        PageInfo *pp1, *pp2;
        PageInfo **tp[2] = { &pp1, &pp2 };
        for (pp = page_free_list; pp; pp = pp->pp_link) {
            int pagetype = PDX(page2pa(pp)) >= pdx_limit;
            *tp[pagetype] = pp; 
            tp[pagetype] = &pp->pp_link;
        }
        *tp[1] = 0;
        *tp[0] = pp2;
        page_free_list = pp1;
    }   

    // if there's a page that shouldn't be on the free list,
    // try to make sure it eventually causes trouble.
    for (pp = page_free_list; pp; pp = pp->pp_link)
        if (PDX(page2pa(pp)) < pdx_limit)
            memset(page2kva(pp), 0x97, 128);

    first_free_page = (char *) boot_alloc(0);
    for (pp = page_free_list; pp; pp = pp->pp_link) {
        // check that we didn't corrupt the free list itself
        assert(pp >= pages);
        assert(pp < pages + npages);
        assert(((char *) pp - (char *) pages) % sizeof(*pp) == 0);

        // check a few pages that shouldn't be on the free list
        assert(page2pa(pp) != 0);
        assert(page2pa(pp) != IOPHYSMEM);
        assert(page2pa(pp) != EXTPHYSMEM - PGSIZE);
        assert(page2pa(pp) != EXTPHYSMEM);
        assert(page2pa(pp) < EXTPHYSMEM || (char *) page2kva(pp) >= first_free_page);

        if (page2pa(pp) < EXTPHYSMEM)
            ++nfree_basemem;
        else
            ++nfree_extmem;
    }

    assert(nfree_basemem > 0);
    assert(nfree_extmem > 0);
}

// Check the physical page allocator (page_alloc(), page_free(), and page_init()).
static void
check_page_alloc(void)
{
	PageInfo *pp, *pp0, *pp1, *pp2;
	int nfree;
	PageInfo *fl;
	char *c;
	int i;

	if (!pages)
		panic("'pages' is a null pointer!");

	// check number of free pages
	for (pp = page_free_list, nfree = 0; pp; pp = pp->pp_link)
		++nfree;

	// should be able to allocate three pages;
	pp0 = pp1 = pp2 = 0;
	assert((pp0 = page_alloc(0)));
	assert((pp1 = page_alloc(0)));
	assert((pp2 = page_alloc(0)));

	assert(pp0);
	assert(pp1 && pp1 != pp0);
	assert(pp2 && pp2 != pp1 && pp2 != pp0);
	assert(page2pa(pp0) < npages * PGSIZE);
	assert(page2pa(pp1) < npages * PGSIZE);
	assert(page2pa(pp2) < npages * PGSIZE);

	// temporarily steal the rest of the free pages
	fl = page_free_list;
	page_free_list = 0;

	// should be no free memory
	assert(!page_alloc(0));

	// free and re-allocate?
	page_free(pp0);
	page_free(pp1);
	page_free(pp2);
	pp0 = pp1 = pp2 = 0;
	assert((pp0 = page_alloc(0)));
	assert((pp1 = page_alloc(0)));
	assert((pp2 = page_alloc(0)));
	assert(pp0);
	assert(pp1 && pp1 != pp0);
	assert(pp2 && pp2 != pp1 && pp2 != pp0);
	assert(!page_alloc(0));

	// test flags
	memset(page2kva(pp0), 1, PGSIZE);
	page_free(pp0);
	assert((pp = page_alloc(ALLOC_ZERO)));
	assert(pp && pp0 == pp);
	c = page2kva(pp);
	for (i = 0; i < PGSIZE; i++)
		assert(c[i] == 0);

	// give free list back
	page_free_list = fl;

	// free the pages we took
	page_free(pp0);
	page_free(pp1);
	page_free(pp2);

	// number of free pages should be the same
	for (pp = page_free_list; pp; pp = pp->pp_link)
		--nfree;
	assert(nfree == 0);

	cprintf("check_page_alloc() succeeded!\n");	
}
