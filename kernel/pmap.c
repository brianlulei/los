#include <include/memlayout.h>
#include <kernel/pmap.h>
#include <kernel/kclock.h>
#include <include/stdio.h>
#include <include/assert.h>
#include <include/string.h>

// These variables are set by i386_detect_memory()
size_t			npages;			// Amount of physical memory (in pages)
static size_t	npages_basemem;	// Amount of base memory (in pages)


// These variables are set in mem_init()
pde_t *kern_pgdir;					// Kernel's initial page directory
PageInfo *pages;					// physical page state array
static PageInfo *page_free_list;	// Free list of physical pages

/*******************************************
 * Detect machine's physical memory setup. *
 *******************************************/
static int
nvram_read(int r)
{
	// Read both low and high bytes to compute the whole value
	return mc146818_read(r) | (mc146818_read(r + 1) << 8);
}


static void
i386_detect_memory(void)
{
	size_t npages_extmem;

	// Use CMOS calls to measure available base & extended memory.
	npages_basemem = (nvram_read(NVRAM_BASELO) * 1024) / PGSIZE;
	npages_extmem = (nvram_read(NVRAM_EXTLO) * 1024) / PGSIZE;

	if (npages_extmem)
		npages = (EXTPHYSMEM / PGSIZE) + npages_extmem;
	else
		npages = npages_basemem;


	cprintf("Physical memory: %uK available, base = %uK, extended = %uK\n",
			npages * PGSIZE / 1024, 
			npages_basemem * PGSIZE / 1024,
			npages_extmem * PGSIZE / 1024);

}


// -------------------------------------
// Set up memory mappings
// -------------------------------------

static void		check_page_free_list(bool only_low_memory);


/* This is a simple physical memory allocator used only while LOS
 * is setting up its virtual memory system.
 *
 * If n > 0, allocates enough pages of contiguous physical memory to hold
 * 'n' bytes. Doesn't initialize the memory. Returns a kernel virtual address.
 *
 * If n == 0, returns the address of the next free page without allocating anything.
 *
 * If out of memory, boot_alloc should panic.
 */

static void*
boot_alloc(uint32_t n)
{
	static char *nextfree = NULL;	// virtual address of next byte of free memory
	char *result;

	// Initialize nextfree if this the first time.
	// 'end' is a symbol automatically generated by the linker,
	// which points to the end of the kernel's bss segment:
	// the first virtual address that the linker does *not* assign
	// to any kernel code or global variables.
	if (!nextfree) {
		extern char end[];
		nextfree = ROUNDUP((char *) end, PGSIZE);
	}

	// Allocate a chunk large enough to hold 'n' bytes, then update
	// nextfree. Make sure nextfree is kept alined to a multiple of PGSIZE

	result = nextfree;
	nextfree = ROUNDUP((nextfree + n), PGSIZE);

	if (PGNUM(PADDR(nextfree)) > npages)
		panic("NO ENOUGH MEMORY");

	return result;
}

/* Set up a two level page table:
 *
 */
void
mem_init(void)
{
	// Find out how much memory the machine has (npages & npages_basemem).
	i386_detect_memory();

	/********************************
	 * Create initial page directory
	 ********************************/
	kern_pgdir = (pde_t *) boot_alloc(PGSIZE);
	memset(kern_pgdir, 0, PGSIZE);

	/***********************************************************
	 * Recursively insert PD in itself as a page table, to form
	 * a virtual page table at virtual address UVPT.
	 ***********************************************************/
	//kern_pgdir

	/*************************************************************************
     * Allocate an array of npages 'struct PageInfo's and store it in 'pages'.
	 * The kernel uses this array to keep track of physical pages: for each
	 * physical page, there is a corresponding struct PageInfo in this array.
	 * 'npages' is the number of physical pages in memory. Use memset to
	 * initialize all fields of each struct PageInfo to 0.
	 *************************************************************************/
	uint32_t pginfo_size = npages * sizeof(PageInfo);
	pages = (PageInfo *) boot_alloc(pginfo_size);
	memset(pages, 0, pginfo_size);

	/*************************************************************************
	 * Now that we've allocated the initial kernel data structures, we set up
	 * the list of free physical pages. Once we've done so, all further memory
	 * management will go through the page_* functions. In particular, we can
	 * now map memory using boot_map_region or page_insert
	 *************************************************************************/

	page_init();

	check_page_free_list(1);
	panic("mem_init: This function is not finished\n");
}
 


/*********************************************************************
 * Initialize page structure and memory free list.
 * After this is done, NEVER use boot_alloc again. ONLY use the page
 * allocator functions below to allocate and deallocate physical
 * memory via the page_free_list.
 *********************************************************************/
void
page_init(void)
{
	// The example code here marks all physical pages as free.
    // However this is not truly the case.  What memory is free?
    //  1) Mark physical page 0 as in use.
    //     This way we preserve the real-mode IDT and BIOS structures
    //     in case we ever need them.  (Currently we don't, but...)
    //  2) The rest of base memory, [PGSIZE, npages_basemem * PGSIZE)
    //     is free.
    //  3) Then comes the IO hole [IOPHYSMEM, EXTPHYSMEM), which must
    //     never be allocated.
    //  4) Then extended memory [EXTPHYSMEM, ...).
    //     Some of it is in use, some is free. Where is the kernel
    //     in physical memory?  Which pages are already in use for
    //     page tables and other data structures?
    //  
    // Change the code to reflect this.
    size_t i;
	extern char end[];

	// 1. Mark physical page 0 as in use.
	pages[0].pp_ref = 0;
	pages[0].pp_link = NULL;
	
	// 2. Mark [PGSIZE, npages_basemem * PGSIZE) free.
	// i is starting from 1
    for (i = 1; i < npages_basemem; i++) {
        pages[i].pp_ref = 0;
        pages[i].pp_link = page_free_list;
        page_free_list = &pages[i];
    }

	// 3. Mark [IOPHYSMEM, EXTPHYSMEM) in use.
	uint32_t ext_page_num = PGNUM(ROUNDUP(EXTPHYSMEM, PGSIZE));
	assert(npages > ext_page_num);

    for (i = npages_basemem; i < ext_page_num; i++) {
        pages[i].pp_ref = 0;
        pages[i].pp_link = NULL;
    }

	// 4. Mark [EXTPHYSMEM, end) in use.
	uint32_t kernel_end_page_num = PGNUM(ROUNDUP(PADDR(end), PGSIZE));

	for (i = ext_page_num; i < kernel_end_page_num; i++) {
		pages[i].pp_ref = 0;
		pages[i].pp_link = NULL;
	}
	
	// 5. Mark kern_pgdir in use.
	uint32_t pginfo_size = npages * sizeof(PageInfo);
	uint32_t pginfo_page_num = PGNUM(ROUNDUP(pginfo_size, PGSIZE));

	// additional 1 is for initial page directory
	for (i = ext_page_num; i < kernel_end_page_num + pginfo_page_num + 1; i++) {
		pages[i].pp_ref = 0;
		pages[i].pp_link = NULL;
	}

	// 6. Mark rest pages free.
	for (; i < npages; i++) {
        pages[i].pp_ref = 0;
        pages[i].pp_link = page_free_list;
        page_free_list = &pages[i];	
	}
}


// -----------------------------------------------------
// Checking functions
// -----------------------------------------------------

static void
check_page_free_list(bool only_low_memory)
{
    PageInfo *pp;
    unsigned pdx_limit = only_low_memory ? 1 : NPDENTRIES;
    int nfree_basemem = 0, nfree_extmem = 0;
    char *first_free_page;

    if (!page_free_list)
        panic("'page_free_list' is a null pointer!");

    if (only_low_memory) {
        // Move pages with lower addresses first in the free
        // list, since entry_pgdir does not map all pages.
        PageInfo *pp1, *pp2;
        PageInfo **tp[2] = { &pp1, &pp2 };
        for (pp = page_free_list; pp; pp = pp->pp_link) {
            int pagetype = PDX(page2pa(pp)) >= pdx_limit;
            *tp[pagetype] = pp; 
            tp[pagetype] = &pp->pp_link;
        }
        *tp[1] = 0;
        *tp[0] = pp2;
        page_free_list = pp1;
    }   

    // if there's a page that shouldn't be on the free list,
    // try to make sure it eventually causes trouble.
    for (pp = page_free_list; pp; pp = pp->pp_link)
        if (PDX(page2pa(pp)) < pdx_limit)
            memset(page2kva(pp), 0x97, 128);

    first_free_page = (char *) boot_alloc(0);
    for (pp = page_free_list; pp; pp = pp->pp_link) {
        // check that we didn't corrupt the free list itself
        assert(pp >= pages);
        assert(pp < pages + npages);
        assert(((char *) pp - (char *) pages) % sizeof(*pp) == 0);

        // check a few pages that shouldn't be on the free list
        assert(page2pa(pp) != 0);
        assert(page2pa(pp) != IOPHYSMEM);
        assert(page2pa(pp) != EXTPHYSMEM - PGSIZE);
        assert(page2pa(pp) != EXTPHYSMEM);
        assert(page2pa(pp) < EXTPHYSMEM || (char *) page2kva(pp) >= first_free_page);

        if (page2pa(pp) < EXTPHYSMEM)
            ++nfree_basemem;
        else
            ++nfree_extmem;
    }

    assert(nfree_basemem > 0);
    assert(nfree_extmem > 0);
}
