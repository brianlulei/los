#include <include/memlayout.h>
#include <kernel/pmap.h>
#include <kernel/kclock.h>
#include <include/stdio.h>
#include <include/assert.h>
#include <include/string.h>

// These variables are set by i386_detect_memory()
size_t			npages;			// Amount of physical memory (in pages)
static size_t	npages_basemem;	// Amount of base memory (in pages)


// These variables are set in mem_init()
pde_t *kern_pgdir;	// Kernel's initial page directory

/*******************************************
 * Detect machine's physical memory setup. *
 *******************************************/
static int
nvram_read(int r)
{
	// Read both low and high bytes to compute the whole value
	return mc146818_read(r) | (mc146818_read(r + 1) << 8);
}


static void
i386_detect_memory(void)
{
	size_t npages_extmem;

	// Use CMOS calls to measure available base & extended memory.
	npages_basemem = (nvram_read(NVRAM_BASELO) * 1024) / PGSIZE;
	npages_extmem = (nvram_read(NVRAM_EXTLO) * 1024) / PGSIZE;

	if (npages_extmem)
		npages = (EXTPHYSMEM / PGSIZE) + npages_extmem;
	else
		npages = npages_basemem;


	cprintf("Physical memory: %uK available, base = %uK, extended = %uK\n",
			npages * PGSIZE / 1024, 
			npages_basemem * PGSIZE / 1024,
			npages_extmem * PGSIZE / 1024);

}

/* This is a simple physical memory allocator used only while LOS
 * is setting up its virtual memory system.
 *
 * If n > 0, allocates enough pages of contiguous physical memory to hold
 * 'n' bytes. Doesn't initialize the memory. Returns a kernel virtual address.
 *
 * If n == 0, returns the address of the next free page without allocating anything.
 *
 * If out of memory, boot_alloc should panic.
 */

static void*
boot_alloc(uint32_t n)
{
	static char *nextfree = NULL;	// virtual address of next byte of free memory
	char *result;

	// Initialize nextfree if this the first time.
	// 'end' is a symbol automatically generated by the linker,
	// which points to the end of the kernel's bss segment:
	// the first virtual address that the linker does *not* assign
	// to any kernel code or global variables.
	if (!nextfree) {
		extern char end[];
		nextfree = ROUNDUP((char *) end, PGSIZE);
	}

	// Allocate a chunk large enough to hold 'n' bytes, then update
	// nextfree. Make sure nextfree is kept alined to a multiple of PGSIZE

	result = nextfree;
	nextfree = ROUNDUP((nextfree + n), PGSIZE);

	if (PGNUM(PADDR(nextfree)) > npages)
		panic("NO ENOUGH MEMORY");

	return result;
}

/* Set up a two level page table:
 *
 */
void
mem_init(void)
{
	// Find out how much memory the machine has (npages & npages_basemem).
	i386_detect_memory();

	kern_pgdir = (pde_t *) boot_alloc(PGSIZE);
	memset(kern_pgdir, 0, PGSIZE);

	panic("mem_init: This function is not finished\n");
}
